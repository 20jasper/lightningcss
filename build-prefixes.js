const prefixes = require('autoprefixer/data/prefixes');
const browsers = require('caniuse-lite').agents;
const fs = require('fs');

const BROWSER_MAPPING = {
  and_chr: 'chrome',
  and_ff: 'firefox',
  ie_mob: 'ie',
  op_mob: 'opera',
  and_qq: null,
  and_uc: null,
  baidu: null,
  bb: null,
  kaios: null,
  op_mini: null,
};

let p = {};
for (let prop in prefixes) {
  let browserMap = {};
  for (let b of prefixes[prop].browsers) {
    let [name, version] = b.split(' ');
    if (BROWSER_MAPPING[name] === null) {
      continue;
    }
    let prefix = browsers[name].prefix_exceptions?.[version] || browsers[name].prefix;
    name = BROWSER_MAPPING[name] || name;
    let v = parseVersion(version);
    if (v == null) {
      console.log('BAD VERSION', prop, name, version);
      continue;
    }
    if (browserMap[name]?.[prefix] == null) {
      browserMap[name] = browserMap[name] || {};
      browserMap[name][prefix] = [v, v];
    } else {
      if (v < browserMap[name][prefix][0]) {
        browserMap[name][prefix][0] = v;
      }

      if (v > browserMap[name][prefix][1]) {
        browserMap[name][prefix][1] = v;
      }
    }
  }
  p[prop] = browserMap;
}

let prefixMapping = {
  webkit: 'WebKit',
  moz: 'Moz',
  ms: 'Ms',
  o: 'O'
};

let enumify = (f) => f.replace(/^@/, 'At').replace(/^::/, 'PseudoElement').replace(/^:/, 'PseudoClass').replace(/(^|-)([a-z])/g, (_, a, x) => x.toUpperCase())

let s = `// This file is autogenerated by build-prefixes.js. DO NOT EDIT!

use serde::{Deserialize, Serialize};
use super::VendorPrefix;

#[derive(Serialize, Debug, Deserialize, Clone, Copy, Default)]
pub struct Browsers {
  pub ${Object.keys(browsers).filter(b => !(b in BROWSER_MAPPING)).sort().join(': Option<u32>,\n  pub ')}: Option<u32>
}

pub enum Feature {
  ${Object.keys(p).map(enumify).sort().join(',\n  ')}
}

impl Feature {
  pub fn prefixes_for(&self, browsers: Browsers) -> VendorPrefix {
    let mut prefixes = VendorPrefix::None;
    match self {
      ${Object.entries(p).map(([name, versions]) => {
        return `Feature::${enumify(name)} => {
        ${Object.entries(versions).map(([name, prefixes]) => {
          return `if let Some(version) = browsers.${name} {
          ${Object.entries(prefixes).map(([prefix, [min, max]]) => {
            if (!prefixMapping[prefix]) {
              throw new Error('Missing prefix ' + prefix);
            }
            return `if version > ${min} && version < ${max} {
            prefixes |= VendorPrefix::${prefixMapping[prefix]};
          }`
          }).join('\n          ')}
        }`;
        }).join('\n        ')}
      }`
      }).join(',\n      ')}
    }
    prefixes
  }
}
`;

fs.writeFileSync('src/properties/prefixes.rs', s);

function parseVersion(version) {
  let [major, minor = '0', patch = '0'] = version
    .split('-')[0]
    .split('.')
    .map(v => parseInt(v, 10));

  if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
    return null;
  }

  return major << 16 | minor << 8 | patch;
}
